No assembly is perfect. To assess the quality of a genome assembly, several values can be used:

- Genome size (close to expectation?)
- number of contigs
- N50 as measure of median contig size
- coverage
- completeness


#### Re-mapping long reads

It can be useful to re-map long reads from PacBio or nanopore to assess the coverage of contigs. `bwa` is a tool that allows this:
```ShellSession
bwa index ref.fa
bwa mem -x pacbio ref.fa pacbio.fq > aln.sam
bwa mem -x ont2d ref.fa ont-2D.fq > aln.sam
```

#### Genome coverage

The coverage can be measured with `bedtools` and a bam-file where genome reads were re-mapped to the assembly. Another file contains contig or chromosome sizes, using the same contig/chromosome names as the bam-file. 

```ShellSession
genomeCoverageBed -ibam genome_remapping.bam -g chr-sizes.txt > coverage.txt
```
The chromosome size file is a simple two-column table like this:
```
Chr_1   3951982
Chr_2   3683506
Chr_3   3351453
Chr_4   2873318
Chr_5   2822964
Chr_6   2483831
Chr_7   2434682
Chr_8   2299506
Chr_9   2122865
Chr_10  2105496
```


#### Assessing completeness with CEGMA and BUSCO

Both CEGMA and BUSCO estimate completeness by searching for the presence and completeness of highly conserved gene sets. CEGMA tests the genome fasta file against a protein database.
```ShellSession
cegma --genome new.genome.fa -o out.file -threads 8
```
BUSCO is a python script. `--out` sets the prefix of the output files, `--in` defines the input (genome fasta file), `--lineage` refers to the reference genome set (here, Ascomycota for conserved fungal genes), `-m` is the input type. 
```ShellSession
# to load the modules (genotoul server)
source /usr/local/bioinfo/src/BUSCO/BUSCO_V3/busco_v3_env/bin/activate;
module load bioinfo/BUSCO_v3;
# to run the script
python /usr/local/bioinfo/src/BUSCO/BUSCO_V3/busco/scripts/run_BUSCO.py -f --out out.file_ --in new.genome.fa --lineage /usr/local/bioinfo/src/BUSCO/datasets/ascomycota_odb9/ -m genome
```
